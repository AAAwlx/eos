# 获取内存容量
>在 Linux 中有多种方法获取内存容量,如果一种方法失败,就会试用其他方法。比如在 Linux 2.6 内核
中,是用 detect_memory 函数来获取内存容量的。其函数在本质上是通过调用 BIOS 中断 Ox15 实现的,分别
是 BIOS 中断 Ox15 的 3 个子功能,子功能号要存放到寄存器 EAX 或 AX 中,如下。\
•
 EAX=OxE820 :遍历主机上全部内存。\
•
 AX=OxE801:
 分别检测低 1 见面和 16孔但~4GB 的内存,最大支持 4GB 。\
•
 AH=Ox88 :最多检测出 64MB 内存,实际内存超过此容量也按照 64MB 返回。

 ## 0xE820
 ![图 3](../../images/fc8b61dcb25177ff86b2169aa2042eda9275dabe3a7c41693429565308c45803.png)  

# 分页机制
## 为什么要启用内存分页机制
1.防止内存碎片化\
2.当内存不够时将长期不使用的进程及时换出至磁盘中保存。
## 如何表示
页表分为两级
![图 2](../../images/5e6552c9231f77d7325c6b6dbb96743f0d880d0d8dd2d4ba8edafcffca942fa0.png)  
(1 )用虚拟地址的高 10 位乘以 4 ,作为页目录表内的偏移地址,加上页目录表的物理地址,所得的
和,便是页目录项的物理地址。读取该页目录项,从中获取到页表的物理地址。\
(2 )用虚拟地址的中间 1 0 位乘以 4 ,作为页表内的偏移地址,加上在第 1 步中得到的页表物理地址,
所得的和,便是页表项的物理地址。读取该页表项,从中获取到分配的物理页地址。 \
(3 )虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PIE 的索引值,所以它们需要乘以 4 。但低 12 位
就不是索引值啦,其表示的范围是 0 ~ Ox筒,作为页内偏移最合适,所以虚拟地址的低 12 位加上第 2 步
中得到的物理页地址,所得的和便是最终转换的物理地址。由 MMU 运算。\
每个进程都有自己的页表，一整个页表可以表示一整个4GB的虚拟地址，任务在切换时,页表也需要跟着切换。、
页表后12位为标志位。
## 页表项中的表示位
![图 1](../../images/9c79f06a07e676f4bb0d9d1a23db7c7fc9aa7d3ff944470f0f95c73717b62d65.png)  
## 开启分页机制
(1 )准备好页目录表及页表。
(2 )将页表物理地址写入控制寄存器cr3 。
(3 )寄存器cr0的PG位置1 。


