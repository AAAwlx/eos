# 获取内存容量
>在 Linux 中有多种方法获取内存容量,如果一种方法失败,就会试用其他方法。比如在 Linux 2.6 内核
中,是用 detect_memory 函数来获取内存容量的。其函数在本质上是通过调用 BIOS 中断 Ox15 实现的,分别
是 BIOS 中断 Ox15 的 3 个子功能,子功能号要存放到寄存器 EAX 或 AX 中,如下。\
•
 EAX=OxE820 :遍历主机上全部内存。\
•
 AX=OxE801:
 分别检测低 1 见面和 16孔但~4GB 的内存,最大支持 4GB 。\
•
 AH=Ox88 :最多检测出 64MB 内存,实际内存超过此容量也按照 64MB 返回。

 ## 0xE820
 ![图 3](../../images/fc8b61dcb25177ff86b2169aa2042eda9275dabe3a7c41693429565308c45803.png)  

# 分页机制
## 为什么要启用内存分页机制
1.防止内存碎片化\
2.当内存不够时将长期不使用的进程及时换出至磁盘中保存。
## 如何表示
页表分为两级
![图 2](../../images/5e6552c9231f77d7325c6b6dbb96743f0d880d0d8dd2d4ba8edafcffca942fa0.png)  
(1 )用虚拟地址的高 10 位乘以 4 ,作为页目录表内的偏移地址,加上页目录表的物理地址,所得的
和,便是页目录项的物理地址。读取该页目录项,从中获取到页表的物理地址。\
(2 )用虚拟地址的中间 1 0 位乘以 4 ,作为页表内的偏移地址,加上在第 1 步中得到的页表物理地址,
所得的和,便是页表项的物理地址。读取该页表项,从中获取到分配的物理页地址。 \
(3 )虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PIE 的索引值,所以它们需要乘以 4 。但低 12 位
就不是索引值啦,其表示的范围是 0 ~ Ox筒,作为页内偏移最合适,所以虚拟地址的低 12 位加上第 2 步
中得到的物理页地址,所得的和便是最终转换的物理地址。由 MMU 运算。\
每个进程都有自己的页表，一整个页表可以表示一整个4GB的虚拟地址，任务在切换时,页表也需要跟着切换。\
页表后12位为标志位。
## 页表项中的表示位
![图 1](../../images/9c79f06a07e676f4bb0d9d1a23db7c7fc9aa7d3ff944470f0f95c73717b62d65.png)  
## 开启分页机制
(1 )准备好页目录表及页表。\
(2 )将页表物理地址写入控制寄存器cr3 。\
(3 )寄存器cr0的PG位置1 。
## 构建映射关系
构建页目录项：
![图 4](../../images/c9b5f2b226e1d2f5d59c90b5e121c1c4a0b8e34fa3f428bdba7e04e5e6b64e4b.png)  
在第0项和第768项都填入第一个页表的地址，在页目录的最后一项填入页目录自己的地址。以后可以通过尾项指到首项的方式来访问自己。
为什么要同时将最低处和0x80000000这两个虚拟地址。\
在加载内核之前，程序中运行的一直都是 loader，它本
身的代码都是在 1MB 之内，必须保证之前段机制下的线性地址和分页后的虚拟地址对应的物理地址一致。\
第 0 个页目录项代表的页表，其表示的空间是 0～0x3fffff，包括了 1MB（0～0xfffff），所以用了第 0 项来保证 loader 在分页机制下依然运行正确。
![图 5](../../images/cd569bfe982e6309a81da80e0f3a60a581ccd069e1be01372fe1672d2d5b8049.png)  
将第1个页表中的最低1M处的物理地址和虚拟地址一一对应，以保证loder能够在分页机制下继续运行。
![图 6](../../images/68b5259c77303134fee12a58d9aedc94d2db359a0e4eebca5ed6ec94090318eb.png)  
将从第769项之后所有的页目录项都填入页表的地址，以便在内核将用户程序载入之后直接复制后1GB的内容。一个完整的用户程序中必须包含操作系统的部分为程序提供最底层的系统调用。将固定的虚拟地址映射到同一个记录有操作系统代码的物理页。

